#!/bin/perl

use FindBin;
use lib "$FindBin::Bin/../lib";
use Patcher qw/ modify_context load_config /;
use Getopt::Long;
use File::Copy;
use File::Slurp;
use Carp qw/ verbose croak /;

my $input = "j/input.exe";
my @output;
my @renames;
my $digest;
my $example;
my $build;
my $bin;


sub set_context {
    my ($opt, $set) = @_;
    my ($k, $v, @rest) = split(/=/, $set);
    die "you must specify key=value for --set-context"
        if not defined $v or @rest;
    modify_context($k => $v);
}

GetOptions(
    "i|input=s"          => \$input,
    "o|output=s"         => \@output,
    "r|renames=s"        => \@renames,
    "d|digest=s"         => \$digest,
    "x|config-example=s" => \$example,
    "b|build-example=s"  => \$build,
    "n|bin=s"            => \$bin,
    "set-context=s"      => \&set_context,
) or die "bad commad line arguments";

if (defined $input) {
    die "no such file $input"
        unless -f $input;
    modify_context("source_input_file exe" => $input);
}

my $o;
if (@output) {
    $o = shift @output;
    modify_context("source_output_file exe" => $o);
}

modify_context(config_example => $example)
    if defined $example;

load_config(@ARGV);

Patcher::apply_and_save();


sub write_file_aux {
    my ($f, $d) = @_;
    write_file($f, $d);
    print "written $f\n";
}

if (defined $bin) {
    my $desc = $Patcher::ctx->{bin_desc_bytes} // "";
    my $relocs = $Patcher::ctx->{reloc_chunk_bytes};
    croak "reloc chunk does not exist"
        unless defined $relocs;

    my $code = $Patcher::ctx->{source_bytes}{bin};
    croak "no bin code is built"
        unless defined $bin;

    my $header = pack(
        "VVV",
        length($desc) + length($relocs) + length($code),    #
        length($desc),
        length($desc) + length($relocs),
    );
    write_file_aux($bin, $header . $desc . $relocs . $code);
}

if (defined $o) {
    for my $copy (@output) {
        print "copy $o $copy\n";
        copy($o, $copy);
    }
}

if (defined $digest) {
    modify_context(
        "settings truncate_long_dumps"      => 100,
        "settings off_name_enclosing_scope" => 1,
    );
    Patcher::print_patches($digest);
}


sub put_generated_file {
    my ($f, $desc, $item) = @_;
    return unless defined $f;
    my $r = Patcher::context_get(qw/ conf_gen generated /, $item);
    croak "no conf_gen generated $item in patcher context"
        unless defined $r;
    write_file_aux($f, $r);
}

put_generated_file($example, "config example",     "config_example");
put_generated_file($build,   "build list example", "build_example");

if (@renames) {
    my $r = shift @renames;
    open my $fh, ">", $r
        or die "unable to open $r: $!";

    my %adjust = (
        ".text" => $Patcher::ctx->{section_base}{".text"},
        ".data" => $Patcher::ctx->{section_base}{".data"},
    );

    my $offs = $Patcher::ctx->{symbol_offset};
    for my $sym (sort { $offs->{$a} <=> $offs->{$b} } keys %$offs) {
        my $sec = $Patcher::ctx->{symbol_section}{$sym};
        next unless exists $adjust{$sec};
        my $off = $offs->{$sym} + $adjust{$sec};
        printf $fh "MakeName(0x%x, '%s_%x');\n", $off, $sym, $off
            if $sec and $off > 0;
    }
    print $fh "SaveBase(\"\");\n";
    print $fh "Exit(0);\n";
    close $fh;

    for my $rcopy (@renames) {
        print "cp $r $rcopy\n";
        copy($r, $rcopy);
    }
}
